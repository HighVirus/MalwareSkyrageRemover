package it.ivirus.skyrageremover.jar;

import it.ivirus.skyrageremover.Main;
import lombok.Getter;
import lombok.experimental.UtilityClass;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.io.*;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@UtilityClass
public class JarCleaner {

    @Getter
    private final Set<String> infectedFileNames = new HashSet<>();

    public List<File> findInfectedJars(File dir) throws IOException {
        return findAllJarsStream(dir).peek(file -> System.out.println("Ready to scan: " + file.getAbsolutePath())).collect(Collectors.toList());
    }

    public List<File> findAllJars(File dir) throws IOException {
        return findAllJarsStream(dir).collect(Collectors.toList());
    }

    public Stream<File> findAllJarsStream(File dir) throws IOException {
        return Files.walk(dir.toPath())
                .map(Path::toFile)
                .filter(File::isFile)
                .filter(file -> {
                    try {
                        return isJarFile(file);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                });
    }

    private boolean isJarFile(File file) throws IOException {
        try (JarInputStream jarStream = new JarInputStream(Files.newInputStream(file.toPath()))) {
            return jarStream.getNextJarEntry() != null;
        }
    }

    public void cleanJar(File file, boolean replaceJar) throws IOException, URISyntaxException {
        String jarName = new File(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()).getName();
        if (jarName.equals(file.getName())) return; //exclude current jar

        File infectedFile = new File(file.getParentFile(), file.getName().replace(".jar", "-infected.jar"));
        Files.move(file.toPath(), infectedFile.toPath(), StandardCopyOption.REPLACE_EXISTING);

        File cleanFile = new File(file.getParentFile(), file.getName().replace(".jar", "-clean.jar"));
        JarFile infectedJarFile = new JarFile(infectedFile);
        JarOutputStream out = new JarOutputStream(new FileOutputStream(cleanFile));
        Enumeration<? extends ZipEntry> entries = infectedJarFile.entries();

        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            zipEntry.setCompressedSize(-1L);


            try (InputStream in = infectedJarFile.getInputStream(zipEntry)) {
                if (zipEntry.getName().endsWith(".class")) {
                    ClassReader classReader = new ClassReader(in);
                    ClassNode classNode = new ClassNode();
                    classReader.accept(classNode, 0);
                    if (classNode.superName == null) continue;
                    if ((classNode.name).equals("Updater")) continue;

                    if (isSynthetic(classNode)) {
                        if (isClassInfected(classNode)) {
                            infectedFileNames.add(file.getAbsolutePath());
                            continue;
                        }
                    }

                    if (isMainClass(classNode) || (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
                            || classNode.superName.equals("net/labymod/api/LabyModAddon")
                            || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin") || classNode.interfaces.stream().anyMatch(s -> s.contains("ClientModInitializer"))
                            || classNode.interfaces.stream().anyMatch(s -> s.contains("ModInitializer")))) {
                        removeVirusFromClass(classNode, file.getAbsolutePath());
                    }

                    ClassWriter cw = new ClassWriter(1);
                    classNode.accept(cw);
                    ZipEntry newEntry = new ZipEntry(zipEntry.getName());
                    out.putNextEntry(newEntry);
                    writeToFile(out, new ByteArrayInputStream(cw.toByteArray()));
                    continue;
                }
                if (zipEntry.getName().equals("plugin-config.bin")) continue;
            } catch (Exception e) {
                e.printStackTrace();
            }

            out.putNextEntry(zipEntry);
            writeToFile(out, infectedJarFile.getInputStream(zipEntry));
        }
        infectedJarFile.close();
        out.close();

        if (replaceJar) {
            infectedFile.delete();
            cleanFile.renameTo(file);
        }
    }

    private boolean isSynthetic(ClassNode classNode) {
        return (classNode.access & Opcodes.ACC_SYNTHETIC) != 0;
    }

    private boolean isMainClass(ClassNode classNode) {
        for (MethodNode methodNode : classNode.methods) {
            if (methodNode.name.equals("main") && methodNode.desc.equals("([Ljava/lang/String;)V")
                    && (methodNode.access & Opcodes.ACC_PUBLIC) != 0 && (methodNode.access & Opcodes.ACC_STATIC) != 0) {
                return true;
            }
        }
        return false;
    }

    private boolean isClassInfected(ClassNode classNode) {
        boolean securityFound = false;
        boolean lwpFound = false;
        boolean f3vfFound = false;
        boolean replaceFound = false;
        for (MethodNode methodNode : classNode.methods) {
            for (AbstractInsnNode insnNode : methodNode.instructions) {
                if (insnNode instanceof LdcInsnNode) {
                    LdcInsnNode ldcInsnNode = (LdcInsnNode) insnNode;
                    if (ldcInsnNode.cst instanceof String) {
                        String s = (String) ldcInsnNode.cst;
                        if (s.equals("security"))
                            securityFound = true;
                        if (s.equals("LWphc"))
                            lwpFound = true;
                        if (s.equals("F3vfPxuGz2WhqAwjhpEhlydqr8ySzoVB"))
                            f3vfFound = true;
                    }
                }
                if (insnNode instanceof FieldInsnNode) {
                    FieldInsnNode fieldInsnNode = (FieldInsnNode) insnNode;
                    if (fieldInsnNode.name.equals("REPLACE_EXISTING"))
                        replaceFound = true;
                }
            }
        }
        return (securityFound && lwpFound && f3vfFound && replaceFound);
    }

    private void removeVirusFromClass(ClassNode classNode, String filePath) {
        for (MethodNode methodNode : classNode.methods) {
            for (AbstractInsnNode insnNode : methodNode.instructions) {
                if (insnNode instanceof MethodInsnNode) {
                    MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;
                    if (isInstruction(methodInsnNode)) {
                        if (methodInsnNode.name.equalsIgnoreCase("init") && methodInsnNode.desc.equals("()V") && methodInsnNode.owner.contains("$")) {
                            methodNode.instructions.remove(insnNode);
                            infectedFileNames.add(filePath);
                        }
                        if ((methodInsnNode.owner + "." + methodInsnNode.name).equalsIgnoreCase("Updater.init")) {
                            methodNode.instructions.remove(insnNode);
                            infectedFileNames.add(filePath);
                        }
                    }
                }
            }
        }
    }

    private void writeToFile(ZipOutputStream outputStream, InputStream inputStream) throws IOException {
        byte[] buffer = new byte[4096];
        try {
            while (inputStream.available() > 0) {
                int data = inputStream.read(buffer);
                outputStream.write(buffer, 0, data);
            }
        } finally {
            inputStream.close();
            outputStream.closeEntry();
        }
    }

    public boolean isInstruction(AbstractInsnNode node) {
        return (!(node instanceof org.objectweb.asm.tree.LineNumberNode) && !(node instanceof org.objectweb.asm.tree.FrameNode) && !(node instanceof org.objectweb.asm.tree.LabelNode));
    }
}
