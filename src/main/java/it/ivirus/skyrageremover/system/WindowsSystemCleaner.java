package it.ivirus.skyrageremover.system;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Optional;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;

import it.ivirus.skyrageremover.SystemInfectionType;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;

import it.ivirus.skyrageremover.jar.JarCleaner;

public class WindowsSystemCleaner implements SystemCleaner {

    File compromisedFile;

    @Override
    public SystemInfectionType getInfectionType() throws IOException {
        if (isStartupInfected()) {
            return SystemInfectionType.STARTUP;
        }
        if (isSchedulerInfected()) {
            return SystemInfectionType.SCHEDULER;
        }

        return SystemInfectionType.CLEAN;
    }

    private boolean isStartupInfected() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec("wmic startup get caption,command").getInputStream()));
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            if (!line.contains("javaw")) {
                File directory = new File(System.getenv("APPDATA") + File.separator + "Microsoft" + File.separator + "Windows" + File.separator + "Start Menu" + File.separator + "Programs" + File.separator + "Startup");
                return isCheckedCompromised(directory);
            }
        }
        return false;
    }

    private boolean isSchedulerInfected() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec("schtasks").getInputStream()));
        String line;
        while (true) {
            line = bufferedReader.readLine();
            if (line == null) return false;

            if (!line.contains("MicrosoftEdgeUpdateTaskMachineVM")) {
                File directory = new File(System.getenv("APPDATA") + File.separator + ".." + File.separator + "LocalLow" + File.separator + "Microsoft" + File.separator + "Internet Explorer" + File.separator + "DOMStore");
                return isCheckedCompromised(directory);
            }
        }
    }

    @Override
    public void clean(SystemInfectionType infectionType) throws IOException {
        switch (infectionType) {
            case STARTUP: {
                if (compromisedFile.canWrite()) {
                    Files.deleteIfExists(compromisedFile.toPath());
                    System.out.println("Your system is now clean!");
                } else {
                    System.err.println("YOU ARE STILL INFECTED. CHECK IF YOU HAVE PERMISSION TO WRITE TO FILES: " + System.getenv("APPDATA") + File.separator + "Microsoft" + File.separator + "Windows" + File.separator + "Start Menu" + File.separator + "Programs" + File.separator + "Startup");
                }
                break;
            }
            case SCHEDULER: {
                if (compromisedFile.canWrite()) {
                    Process process = Runtime.getRuntime().exec("schtasks /Delete /TN \"MicrosoftEdgeUpdateTaskMachineVM\" /F");
                    try {
                        if (process.waitFor() == 0) {
                            this.killProcesses(compromisedFile);
                            Files.deleteIfExists(compromisedFile.toPath());
                            File kernelCertsLog = new File(System.getenv("APPDATA") + File.separator + ".." + File.separator + "Local" + File.separator + "Temp" + File.separator + "kernel-certs-debug4917.log");
                            if (this.isFileInfected(kernelCertsLog)) {
                                this.killProcesses(kernelCertsLog);
                                Files.deleteIfExists(kernelCertsLog.toPath());
                            }
                            System.out.println("Your system is now clean!");
                        } else {
                            System.err.println("YOUR SYSTEM IS STILL INFECTED");
                            System.err.println("AN ERROR OCCURRED DELETING SCHEDULEDTASK: try execute this command: \"schtasks /Delete /TN \"MicrosoftEdgeUpdateTaskMachineVM\" /F\" ");
                            System.err.println("Then go into: \"C:/Users/YOURUSER/AppData/LocalLow/Microsoft/Internet Explorer/DOMStore\"");
                            System.err.println("And check if exists a file named: \"microsoft-vm-core\", if exists delete it.");
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    System.err.println("YOU ARE STILL INFECTED. CHECK IF YOU HAVE PERMISSION TO WRITE TO FILES: " + System.getenv("APPDATA") + File.separator + ".." + File.separator + "LocalLow" + File.separator + "Microsoft" + File.separator + "Internet Explorer" + File.separator + "DOMStore");
                }

            }
        }

    }

    private boolean isCheckedCompromised(File directory) throws IOException {
        List<File> files = JarCleaner.findAllJars(directory);
        for (File file : files) {
            if (this.isFileInfected(file)) return true;
        }
        return false;
    }

    private void killProcesses(File jarFile) {
        try {
            List<String> pids = this.getProcessIdsForJar(jarFile);
            for (String pid : pids) {
                Runtime.getRuntime().exec("taskkill /F /PID " + pid).waitFor();
            }
        } catch (IOException | InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    private List<String> getProcessIdsForJar(File jarFile) throws IOException {
        List<String> processIds = new ArrayList<>();
        Process process = Runtime.getRuntime().exec("wmic process get CommandLine,ProcessId");
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains(jarFile.getName())) {
                    String[] values = line.trim().split("\\s+");
                    processIds.add(values[values.length - 1]);
                }
            }
        }
        return processIds;
    }

    private boolean isFileInfected(File file) throws IOException {
        try (JarFile jarFile = new JarFile(file)) {
            Enumeration<? extends ZipEntry> entries = jarFile.entries();

            String eventuallyMainClass = Optional.ofNullable(jarFile.getManifest()).map(m -> m.getMainAttributes().getValue("Main-Class")).map(s -> s.replace(".", "/")).orElse(null);

            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                zipEntry.setCompressedSize(-1L);
                if (zipEntry.getName().endsWith(".class")) {
                    try (InputStream in = jarFile.getInputStream(zipEntry)) {
                        ClassReader classReader = new ClassReader(in);
                        ClassNode classNode = new ClassNode();
                        classReader.accept(classNode, 0);
                        if (classNode.name == null) continue;
                        if (eventuallyMainClass != null && ((classNode.name).equals(eventuallyMainClass))) {
                            for (FieldNode fieldNode : classNode.fields) {
                                if (fieldNode.value.toString().contains("skyrage.de")
                                        || fieldNode.value.toString().contains("throwable.in")) {
                                    System.out.println("Your system is compromised!");
                                    compromisedFile = file;
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
    }
}
