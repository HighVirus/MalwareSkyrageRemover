package it.ivirus.skyrageremover;


import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Scanner;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class Main {

    public List<File> jars = new ArrayList<>();

    public static void main(String[] args) throws Throwable {
        Main main = new Main();
        File output = new File(args[1]);
        if (!output.exists())
            output.mkdir();

        System.out.println("");
        System.out.println(":::    :::  ::::::::  :::    ::: ::::::::::: :::::::::::     :::     ");
        System.out.println(":+:    :+: :+:    :+: :+:    :+:     :+:         :+:       :+: :+:   ");
        System.out.println("+:+    +:+ +:+    +:+  +:+  +:+      +:+         +:+      +:+   +:+  ");
        System.out.println("+#++:++#++ +#+    +:+   +#++:+       +#+         +#+     +#++:++#++: ");
        System.out.println("+#+    +#+ +#+    +#+  +#+  +#+      +#+         +#+     +#+     +#+ ");
        System.out.println("#+#    #+# #+#    #+# #+#    #+#     #+#     #+# #+#     #+#     #+# ");
        System.out.println("###    ###  ########  ###    ### ###########  #####      ###     ### ");
        System.out.println("");
        System.out.println("Developer: iVirus_");
        System.out.println("Telegram: https://t.me/HoxijaChannel");
        System.out.println("Discord: https://discord.io/hoxija");
        System.out.println("");

        System.out.println("Checking jars...");
        System.out.println("");

        main.getJars(args[0]);

        for (File file : main.jars) {
            System.out.println(file.getName() + " is infected.");
        }
        System.out.println("");
        System.out.println("Total jars infected: " + main.jars.size());
        System.out.println("");
        main.chooseAction(new Scanner(System.in), output);


    }

    private void chooseAction(Scanner scanner, File output) throws Throwable {
        System.out.println("Type \"Y\" to clean your jars or any other character to close.");
        String value = scanner.nextLine();
        if (value.equalsIgnoreCase("y")) {
            System.out.println("");
            System.out.println("I'm cleaning your jars! This may take some time.");
            int i = 0;
            for (File file : this.jars) {
                this.runRemover(file, output);
                this.cleanSystem();
                i++;
                System.out.println("Status: " + i + "/" + this.jars.size());
            }
        } else {
            System.out.print("Closing...");
        }
    }

    public void getJars(String folder) {
        File directory = new File(folder);

        File[] fList = directory.listFiles();
        if (fList != null)
            for (File file : fList) {
                if (file.isFile()) {
                    if (file.getName().toLowerCase().endsWith(".jar")) {
                        try (ZipFile zip = new ZipFile(file)) {
                            Enumeration<? extends ZipEntry> entries = zip.entries();
                            while (entries.hasMoreElements()) {
                                ZipEntry zipEntry = entries.nextElement();
                                zipEntry.setCompressedSize(-1L);
                                if (zipEntry.getName().endsWith("plugin-config.bin")) {
                                    this.jars.add(file);
                                    break;
                                }
                            }

                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }

                    }
                } else if (file.isDirectory()) {
                    getJars(file.getAbsolutePath());
                }
            }
    }

    public void runRemover(File file, File filePath) throws Throwable {
        JarFile jarFile = new JarFile(String.valueOf(file.toPath()));
        JarOutputStream out = new JarOutputStream(Files.newOutputStream(new File(filePath.getAbsolutePath() + "/" + file.getName()).toPath()));
        Enumeration<? extends ZipEntry> entries = jarFile.entries();
        String eventuallyMainClass = "hoxija";

        Manifest manifest = jarFile.getManifest();

        if (eventuallyMainClass.equals("hoxija") && manifest != null && manifest.getMainAttributes().getValue("Main-Class") != null) {
            eventuallyMainClass = manifest.getMainAttributes().getValue("Main-Class");
            eventuallyMainClass = eventuallyMainClass.replaceAll("\\.", "/");
        }
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            zipEntry.setCompressedSize(-1L);

            if (zipEntry.getName().endsWith(".class")) {
                try (InputStream in = jarFile.getInputStream(zipEntry)) {
                    ClassReader classReader = new ClassReader(in);
                    ClassNode classNode = new ClassNode();
                    classReader.accept(classNode, 0);
                    if (classNode.superName == null) continue;
                    if ((classNode.name).equals("Updater")) continue;
                    if (!eventuallyMainClass.equals("hoxija")) {
                        if ((classNode.name).equals(eventuallyMainClass)) {
                            outloop:
                            for (MethodNode methodNode : classNode.methods) {
                                for (AbstractInsnNode insnNode : methodNode.instructions) {
                                    if (insnNode instanceof MethodInsnNode) {
                                        MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;
                                        if (isInstruction(methodInsnNode)) {
                                            if ((methodInsnNode.owner + "." + methodInsnNode.name).equalsIgnoreCase("Updater.init")) {
                                                methodNode.instructions.remove(insnNode);
                                                break outloop;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")) {
                        outloop:
                        for (MethodNode methodNode : classNode.methods) {
                            for (AbstractInsnNode insnNode : methodNode.instructions) {
                                if (insnNode instanceof MethodInsnNode) {
                                    MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;
                                    if (isInstruction(methodInsnNode)) {
                                        if ((methodInsnNode.owner + "." + methodInsnNode.name).equalsIgnoreCase("Updater.init")) {
                                            methodNode.instructions.remove(insnNode);
                                            break outloop;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ClassWriter cw = new ClassWriter(1);
                    classNode.accept(cw);
                    ZipEntry newEntry = new ZipEntry(zipEntry.getName());
                    out.putNextEntry(newEntry);
                    writeToFile(out, new ByteArrayInputStream(cw.toByteArray()));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                continue;
            }
            if (zipEntry.getName().equals("plugin-config.bin")) continue;
            out.putNextEntry(zipEntry);
            writeToFile(out, jarFile.getInputStream(zipEntry));
        }
        jarFile.close();
        out.close();
    }

    private void cleanSystem() {
        File fileVmd = new File("/bin/vmd-gnu");
        File fileService = new File("/etc/systemd/system/vmd-gnu.service");
        boolean failed = false;
        try {
            Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", "systemctl stop vmd-gnu"}).waitFor();
            Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", "systemctl disable vmd-gnu"}).waitFor();
        } catch (InterruptedException | IOException e) {
            throw new RuntimeException(e);
        }

        if (fileVmd.canWrite()) {
            try {
                Files.deleteIfExists(fileVmd.toPath());
            } catch (IOException e) {
                failed = true;
                e.printStackTrace();
            }
        }
        if (fileService.canWrite()) {
            try {
                Files.deleteIfExists(fileService.toPath());
            } catch (IOException e) {
                failed = true;
                e.printStackTrace();
            }
        }

        if (failed) {
            System.err.println("There was an error cleaning system level malware.");
            System.err.println("YOU ARE STILL INFECTED. CHECK IF YOU HAVE PERMISSION TO WRITE TO FILES: /bin/vmd-gnu   ,   /etc/systemd/system/vmd-gnu.service");
            System.err.println("You can also remove files manually. remember to execute after delete: systemctl disable vmd-gnu");
        }

    }

    private static void writeToFile(ZipOutputStream outputStream, InputStream inputStream) throws Throwable {
        byte[] buffer = new byte[4096];
        try {
            while (inputStream.available() > 0) {
                int data = inputStream.read(buffer);
                outputStream.write(buffer, 0, data);
            }
        } finally {
            inputStream.close();
            outputStream.closeEntry();
        }
    }

    public static boolean isInstruction(AbstractInsnNode node) {
        return (!(node instanceof org.objectweb.asm.tree.LineNumberNode) && !(node instanceof org.objectweb.asm.tree.FrameNode) && !(node instanceof org.objectweb.asm.tree.LabelNode));
    }
}
